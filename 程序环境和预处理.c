#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
// 编译(预编译 得到.i文件 -> 编译 得到.s 文件  ->  汇编 得到.o 文件 )  -> 链接   -> .exe文件

// 预定义符号：
// 下面是c语言里面定义好的，内置的，可以拿来直接使用
//__FILE__ //进行编译的源文件
//__LINE__　//当前文件的行号
//__DATE__ //文件被编译的日期
//__TIME__ //文件被编译的时间
//__STDC__　// 如果编译器遵循ANSI C，其值为1，否则未定义


//int main()
//{
//	printf("%d", __STDC__);// vs 编译器不遵循 ANSI C
//  // gcc编译器遵循 ANSI C标准
//	return 0;
//}
//
//// 打印日志
//int main()
//{
//	FILE* pf = fopen("C:\\Users\\20841\\Desktop\\log.txt","w");
//	if (pf == NULL)
//	{
//		perror("file");
//		return 1;
//
//	}
//
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		// 写到pf指向的文件里面去
//		fprintf(pf,"file: %s line=%d date=%s time=%s i=%d\n", __FILE__,__LINE__,__DATE__, __TIME__,i);
//
//	}
//	fclose(pf);
//	pf = NULL;
//
//	return 0;
//}

// #difine 定义的标识符，在预处理时被进行替换
// 注意不要在#define定义的后面加分号
//#define MAX 1000
//#define STR "hello"
//#define reg register // 为rigister逐个关键字，创建一个简单的名字
//#define do_forever for(; ;) //替换一段代码

// 例如：int i =MAX; 会被替换成 int i=1000;

// 续行符: \
// 表示连接上下两行代码，用在一行的末尾

//#define 定义宏
// #define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏或定义宏
// 宏只完成替换，不进行任何的计算
// 定义宏的时候一定不要吝啬括号的使用

// 宏的声明方式：
//  #define 宏名字(参数列表) 宏体
//  其中参数列表是一个由逗号分隔开的符号表（类似于函数的参数，只是不需要类型）这些参数可能出现在宏体中
//  在预处理的时候，把参数替换到宏体里面去
// 注意：
// 参数列表的左括号必须与宏名紧挨着，中间不能有空格，否则就变成了类型定义
// 如果宏民和参数列表的左括号中间有任何空白存在，参数列表就会被解释为宏体的一部分
// 宏在定义的时候最好把每个宏体里的参数都单独括号括起来，并且把全部的宏体整体括号起来，防止使用时出现错误！
// 所以对于数值表达式进行求值的宏定义都应该加上括号，避免在使用宏的时候由于参数中的操作符或者临近操作符中间不可预料的相互作用

// 举例：
//#define SQUARE(X) ((X)*(X))// 给X加上括号是为了避免使用时的优先级问题
//
//#define DOUBLE(X) ((X)+(X))
//// 反例：不加括号引发的问题
//// 如果定义为 #define SQUARE(X) X*X
//// 那么如果 int r=SQUARE(5+1) 就会变成  int r= 5+1*5+1 ，结果就变成了11，而不是想要的结果
//// 而如果使用#define SQUARE(X) (X)*(X)，那么就不会出现问题 int r=(5+1)*(5+1)  结果正确
//// 
//
//int main()
//{
//	int r = SQUARE(5 + 1);
//	printf("%d\n", r);
//	int r1 = 10*DOUBLE(5 * 2);// 这就体现了在整体宏体外面加上括号的好处了
//	// 如果不加，那么就是 int r1 = 10* (5*2)+(5*2) 结果是 110
//	// 加上括号，就是int r1=10*  (   (5*2)+(5*2)  )  结果是200
//	// 二者结果截然不同！因此括号很重要！
//	printf("%d\n", r1);
//
//	return 0;
//}

//#define 替换规则：
// 在程序在拓展#define定义的符号和宏时，需要涉及以下几个步骤：
// 1.在调用宏的时候，首先对参数进行检查，看看是否包含任何有#define定义的符号，如果包含，他们首先被替换
// 2.替换文本随后被插入到程序中原来文本的位置，对于宏，参数名被他们的值所替换
// 3.最后，再对结果文件进行扫描，看看是否包含任何有#define定义的符号，如果有，就重复上述过程

// 注意：
// 宏参数和#define定义中可以出现其他#define定义的符号。但是对于宏，不能出现递归
// 当预处理搜索#define定义的符号时，字符串常量的内容并不被搜索

// 举例：
//#define M 100
//#define DOUBLE(X) ((X)+(X))
//int main()
//{
//	int r = DOUBLE(M + 100);
//	// 先把 M替换成为100 ，得到 ->  int r=DOUBLE(100+100);
//	// 再继续把宏DOUBLE替换 得到 ->  int r= （  (100+100) + (100+100））;
//	// 然后再继续……
//
//	char c1="M";// 这是字符串，不会被替换
//	char c2="DOUBLE(3)";//这是字符串，不会被替换
//
//	return 0;
//}

// 知识补充： 两个相邻的字符串可以拼接为一个字符串
//  字符串有自动连接的特点
// 例如：printf("hello ""bit\n") 的结果 和 printf("hello bir\n")   的结果一样

// # 和 ##
// #  在宏中使用表示 把传过来的某个宏体中的参数 设置为字符串
// 举例：
//#define PRINT(N) printf("the value of "#N" is %d\n",N)
//// #N 表示 把N 以字符串->  "N" 表示
//int main()
//{
//	int a = 10;
//	PRINT(a);// 就是 ->  printf("the value of ""a"" is %d\n",a);
//	//输出结果是：the value of a is 10
//	int b = 100;
//	PRINT(b);// 就是 ->  printf("the value of ""b"" is %d\n",b);
//	//输出结果是：the value of b is 100
//
//	return 0;
//}
// 再举例：
// 定义一个以某种格式打印的宏
//#define PRINT(N,Format) printf("the value of "#N" is "Format,N)
//int main()
//{
//	int a = 10;
//	PRINT(a, "%d\n");// 就是 -> printf("the value of a is %d\n",a);
//	// 输出结果是：the value of a is 10
//
//	float f = 3.14f;
//	PRINT(f, "%f\n");// 就是 -> printf("the value of f is %f\n",f);
//	// 输出结果是： the value of f is 3,14
//
//	return 0;
//}

// ##
// ## 可以把位于它两边的符号合成一个符号
// 它允许宏定义从分离的文本片段创建标识符
// 注意：使用##连接产生的结果必须是一个合法的标识符，否则其结果是未定义的
// 举例：
//#define CAT(Class,Num) Class##Num// 结果是 -> ClassNum
//int main()
//{
//	int Class106 = 100;
//	printf("%d\n", CAT(Class, 106));// 就是 -> printf("%d\n",Class106);
//	
//	return 0;
//}

// 谨慎定义带有副作用的宏参数！
// 当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就有可能出现危险
// 导致不可预测的结果。副作用就是表达式求值的时候出现的要继续效果
// 例如: a++
// 最好不要使用和定义带有副作用的宏参数！
// 错误示例：
//#define MAX(x,y) ((x)>(y)?(x):(y))
//int main()
//{
//	int a = 5;
//	int b = 4;
//	int m = MAX(a++, b++);//就是-> int m = (  (a++)>(b++) ? (a++):(b++) );
//	// 再次提醒：宏只完成替换，并不进行计算！！！
//
//	printf("m=%d\n", m);//6
//	printf("a=%d b=%d\n", a, b);// a=7 b=5
//
//	return 0;
//}

// 宏的优点：
// 1.宏比函数在程序的规模和速度方面更胜一筹
// 2.宏的参数是类型无关的
// 宏的缺点：
// 1.每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度
// 2.宏是没法调试的（预编译阶段就完成替换了）
// 3.宏参数是类型无关的，不够严谨
// 4.宏可能带来运算优先级问题，导致程序出错，可以通过加括号解决

// 宏有时候可以做函数做不到的事情，比如：宏的参数可以是 类型，但函数做不到
// 对于宏和函数，如果代码非常简单，可以使用宏，如果比较复杂，使用函数。


// 命名约定：
// 一般来说函数和宏的使用语法很相似，所以语言本身没法帮我们区分二者
// 一般把 宏名 全部大写
//  一般函数名不要全部大写、

//#undef // 用于取消宏定义
// 语法：
// #undef 宏名  // 取消宏定义

// 命令行定义：
// 许多c的编译器提供了一种能力，允许在命令行中定义符号，用于启动编译过程。
// 例如：当我们根据同一个源文件要编译出一个程序的不同版本的时候，这个特性有点用处。（假定某个程序中
// 声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一个机器内存大些，我们需要一个数组能够大些。
// 例如把一个符号当成一个数组的大小，但是不进行定义，而是在编译的时候通过命令行来进行定义。

// 条件编译
// 在编译某一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。那就是使用条件编译指令
// 比如说：调试性的代码，删除可惜，保留又碍事，所以我们可以选择性的编译
// 常见的条件编译指令：
// 1.  
// #if  常量表达式
//      语句
// #endif
// 2.多个分支的条件编译
// #if 常量表达式
//      语句
// #elif  常量表达式
//       语句
// #else
//       语句
// #endif
// 3.判断是否被定义
// #if defind(符号)   或者   #ifdef 符号
// 4.判断是否没有被定义
// #if !defined(符号)  或者  #ifndef 符号
// 5.嵌套指令
// #if defined(符号)
//     #ifdef 表达式
//           语句
//	   #endif
//	   #ifdef 符号
//	        语句
//     #endif
// #elseif defined 符号
//     #ifdef 符号
//        语句
//     #endif
// #endif
//     

// 文件包含
// #include 指令可以使另外一个文件被编译，就像他实际出现于#include 指令的地方一样
// 这种替换的方式很简单
// 预处理器先删除这条指令，并用包含文件的内容替换
// 同一个头文件如果被多次包含在同一个文件里面，那么就实际被编译多次
// 因此要防止同一个头文件被多次包含（可以使用条件编译来解决）
// 避免同一个头文件被多次包含（写在头文件里面）
// 方式1：条件编译
// 每个头文件都按照下面这个格式写：
// #ifndef __TEST_H___
// #defined __TEST_H__
//       头文件的内容
// #endif
// 
// 例如：防止重复包含test.h
// #ifndef __TEST_H__  //符号随意命名
// #defined __TEST_H__
//       int Add(int x,int y);
// #endif
// 方式2：#pragma once  其用途是保证头文件在编译期间仅被包含一次，避免因重复包含头文件而产生重复定义的错误。
// #pragma once
//    头文件内容
// 
// 例如：
// #pragma once  
// int Add(int x,int y);


// 关于   #include <>  和  #include ""
// 例如 ： #include <stdio.h> 和  #include "test.h"
// <> 和 "" 的区别就是查找的策略不同
// <> 查找策略：直接去库目录下查找
// "" 查找策略：先去代码所在的路径下查找，如果查找不到，再去库目录下查找，如果查找不到 报错
